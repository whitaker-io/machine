# Plugins

## Overview
Plugins provide a way for vertex functions to be declared and run dynamically. This provides the Developer with flexibility in the systems that they run. This flexibility though useful comes with the drawback of a minor performance hit, so the Developer must take this into consideration when processing large amounts of data.

### Types

[ProviderDefinitions](https://pkg.go.dev/github.com/whitaker-io/machine#ProviderDefinitions) - is a type for mapping the `PluginDefinition`s by name and loading them.

----

[PluginDefinition](https://pkg.go.dev/github.com/whitaker-io/machine#PluginDefinition) - is a type for holding configuration used to load a Vertex Provider from a PluginProvider.

----

[PluginProvider](https://pkg.go.dev/github.com/whitaker-io/machine#PluginProvider) - is an interface to provide the Vertex Provider functions. 

This interface has a single method 
```golang
func Load(*machine.PluginDefinition) (interface{}, error)
```

This method takes a *`machine`.`PluginDefinition` and uses that information to create what is referred to as a Vertex Provider. The possible Vertex Providers are as follows:

```golang
  func(map[string]interface{}) machine.Subscription
  func(map[string]interface{}) machine.Retriever
  func(map[string]interface{}) machine.Applicative
  func(map[string]interface{}) machine.Fold
  func(map[string]interface{}) machine.Fork
  func(map[string]interface{}) machine.Sender
```

These functions when appropriate take a `map`[`string`]`interface`{} containing attributes used to modify the runtime of the Vertex Function that is returned. 

----

[StreamSerialization](https://pkg.go.dev/github.com/whitaker-io/machine#StreamSerialization) - is a type for holding configuration used to define a `Steam` that will be run in the `Pipe`. It is used with the subtype:

[VertexSerialization](https://pkg.go.dev/github.com/whitaker-io/machine#VertexSerialization) - type for holding configuration of individual Vertices in a `Stream`

## Usage

There are 2 steps to using Plugin based steams

1.) Load the plugins with the `PluginDefinition`'s Load method
2.) Load the `Stream`s with the `Pipe`'s Load method


## Examples

This example is from the main.go generated by the [Foundry](https://github.com/whitaker-io/foundry) create command. It uses [viper](https://github.com/spf13/viper) to load a configuration file in the form 

```yaml
	fiber:
		config: # https://godoc.org/github.com/gofiber/fiber#Config
	plugins: # map of machine.PluginDefinition https://godoc.org/github.com/whitaker-io/machine#PluginDefinition
	machine:
		port: 5000 # int port value
		grace_period: 10 # int number of seconds to allow for graceful shutdown
		serializations: # list of machine.StreamSerialization https://godoc.org/github.com/whitaker-io/machine#StreamSerialization
```

```golang
		
func main() {
	fiberConfig := fiber.Config{}

	if err := viper.UnmarshalKey(fiberConfigKey, &fiberConfig); err != nil {
		fmt.Printf("error unmarshalling fiber config [%v]\n", err)
		os.Exit(1)
	}

	pd := &machine.ProviderDefinitions{
		Plugins: map[string]*machine.PluginDefinition{},
	}

	if err := viper.UnmarshalKey(pluginKey, &pd.Plugins); err != nil {
		fmt.Printf("error unmarshalling plugin definitions [%v]\n", err)
		os.Exit(1)
	} else if err := pd.Load(); err != nil {
		fmt.Printf("error loading plugins [%v]\n", err)
		os.Exit(1)
	}

	serializations := []*machine.StreamSerialization{}

	if err := viper.UnmarshalKey(serializationKey, &serializations); err != nil {
		fmt.Printf("error unmarshalling serializations [%v]\n", err)
		os.Exit(1)
	}

	if len(serializations) < 1 {
		fmt.Printf("no serializations found\n")
		os.Exit(1)
	}

	port := viper.GetInt(machinePortKey)
	gracePeriod := viper.GetInt64(machineGracePeriodKey)

	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt)
	<-quit
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(gracePeriod)*time.Second)
	defer cancel()

	pipe := machine.NewPipe(uuid.New().String(), Logger, LogStore, fiberConfig)

	if err := pipe.Load(serializations); err != nil {
		fmt.Printf("error loading serializations %v\n", err)
		os.Exit(1)
	}

	if err := loader.LoadAll(pipe); err != nil {
		fmt.Printf("error loading streams from loader %v\n", err)
		os.Exit(1)
	}

  if err := pipe.Run(ctx, ":"+strconv.Itoa(port), time.Duration(gracePeriod)*time.Second); err != nil {
    fmt.Printf("error running pipe [%v]", err)
    os.Exit(1)
  }
}
```