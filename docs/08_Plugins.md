# Plugins

## Overview
Plugins provide a way for vertex functions to be declared and run dynamically. This provides the Developer with flexibility in the systems that they run. This flexibility though useful comes with the drawback of a minor performance hit, so the Developer must take this into consideration when processing large amounts of data.

### Types

[PluginDefinition](https://pkg.go.dev/github.com/whitaker-io/machine#PluginDefinition) - is a type for holding configuration used to load a Vertex Provider from a PluginProvider.

----

[PluginProvider](https://pkg.go.dev/github.com/whitaker-io/machine#PluginProvider) - is an interface to provide the Vertex Provider functions. 

This interface has a single method 
```golang
func Load(*machine.PluginDefinition) (interface{}, error)
```

This method takes a *`machine`.`PluginDefinition` and uses that information to create a Vertex Type. The possible Vertex Types are as follows:

```golang
  machine.Subscription
  machine.Retriever
  machine.Applicative
  machine.Fold
  machine.Fork
  machine.Publisher
```

----

[StreamSerialization](https://pkg.go.dev/github.com/whitaker-io/machine#StreamSerialization) - is a type for holding configuration used to define a `Steam` that will be run in the `Pipe`. It is used with the subtype:

[VertexSerialization](https://pkg.go.dev/github.com/whitaker-io/machine#VertexSerialization) - type for holding configuration of individual Vertices in a `Stream`

## Examples

This example is from the main.go generated by the [Foundry](https://github.com/whitaker-io/foundry) create command. It uses [viper](https://github.com/spf13/viper) to load a configuration file example below: 


```golang
    
func main() {
  fiberConfig := fiber.Config{}

  if err := viper.UnmarshalKey(fiberConfigKey, &fiberConfig); err != nil {
    fmt.Printf("error unmarshalling fiber config [%v]\n", err)
    os.Exit(1)
  }

  serializations := []*machine.StreamSerialization{}

  if err := viper.UnmarshalKey(serializationKey, &serializations); err != nil {
    fmt.Printf("error unmarshalling serializations [%v]\n", err)
    os.Exit(1)
  }

  if len(serializations) < 1 {
    fmt.Printf("no serializations found\n")
    os.Exit(1)
  }

  port := viper.GetInt(machinePortKey)
  gracePeriod := viper.GetInt64(machineGracePeriodKey)

  quit := make(chan os.Signal, 1)
  signal.Notify(quit, os.Interrupt)
  <-quit
  ctx, cancel := context.WithTimeout(context.Background(), time.Duration(gracePeriod)*time.Second)
  defer cancel()

  pipe := machine.NewPipe(uuid.New().String(), Logger, LogStore, fiberConfig)

  if err := pipe.Load(serializations); err != nil {
    fmt.Printf("error loading serializations %v\n", err)
    os.Exit(1)
  }

  if err := loader.LoadAll(pipe); err != nil {
    fmt.Printf("error loading streams from loader %v\n", err)
    os.Exit(1)
  }

  if err := pipe.Run(ctx, ":"+strconv.Itoa(port), time.Duration(gracePeriod)*time.Second); err != nil {
    fmt.Printf("error running pipe [%v]", err)
    os.Exit(1)
  }
}
```

```yaml
  fiber:
    config: # https://godoc.org/github.com/gofiber/fiber#Config
  plugins: # map of machine.PluginDefinition https://godoc.org/github.com/whitaker-io/machine#PluginDefinition
    testSubscription: &testSubscription
      type: test
      symbol: testing.Subscription
      payload: ""
    testRetriever: &testRetriever
      type: test
      symbol: testing.Retriever
      payload: ""
    testApplicative: &testApplicative
      type: test
      symbol: testing.Applicative
      payload: ""
    testFold: &testFold
      type: test
      symbol: testing.Fold
      payload: ""
    testFork: &testFork
      type: test
      symbol: testing.Fork
      payload: ""
    testPublisher: &testPublisher
      type: test
      symbol: testing.Publisher
      payload: ""
  machine:
    port: 5000 # int port value
    grace_period: 10 # int number of seconds to allow for graceful shutdown
    serializations: # list of machine.StreamSerialization https://godoc.org/github.com/whitaker-io/machine#StreamSerialization
    - type: subscription
      interval: 100000
      id: subscription_test_id
      provider: 
        <<: *testSubscription
      map:
        id: applicative_id
        provider: 
          <<: *testApplicative
        fold_left:
          id: fold_id
          provider: 
            <<: *testFold
          fold_right:
            id: fold_id
            provider: 
              <<: *testFold
            fork:
              id: fork_id
              provider: 
                <<: *testFork
              left:
                transmit:
                  id: sender_id
                  provider: 
                    <<: *testSender
              right:
                loop:
                  id: loop_id
                  provider: 
                    <<: *testFork
                  in:
                    map:
                      id: applicative_id
                      provider: 
                        <<: *testApplicative
                      fold_left:
                        id: fold_id
                        provider: 
                          <<: *testFold
                        fold_right:
                          id: fold_id
                          provider: 
                            <<: *testFold
                          fork:
                            id: fork_id
                            provider: 
                              <<: *testFork
                            left:
                              map:
                                id: applicative_id
                                provider: 
                                  <<: *testApplicative
                            right:
                              loop:
                                id: loop_id
                                provider: 
                                  <<: *testFork
                                in:
                                  transmit:
                                    id: sender_id
                                    provider: 
                                      <<: *testSender
                                out:
                                  transmit:
                                    id: sender_id
                                    provider: 
                                      <<: *testSender
                  out:
                    transmit:
                      id: sender_id
                      provider: 
                        <<: *testSender
    - type: http
      id: http_test_id
      map:
        id: applicative_id
        provider: 
          <<: *testApplicative
        fold_left:
          id: fold_id
          provider: 
            <<: *testFold
          fork:
            id: fork_id
            provider: 
              <<: *testFork
            left:
              transmit:
                id: sender_id
                provider: 
                  <<: *testSender
            right:
              transmit:
                id: sender_id
                provider: 
                  <<: *testSender
    - type: stream
      id: stream_test_id
      provider: 
        <<: *testRetriever
      map:
        id: applicative_id
        provider: 
          <<: *testApplicative
        fold_left:
          id: fold_id
          provider: 
            <<: *testFold
          fork:
            id: fork_id
            provider: 
              <<: *testFork
            left:
              transmit:
                id: sender_id
                provider: 
                  <<: *testSender
            right:
              transmit:
                id: sender_id
                provider: 
                  <<: *testSender
```